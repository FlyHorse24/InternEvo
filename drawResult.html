<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Visualization</title>
    <style>
        canvas {
            border: 1px solid #ccc;
            margin: 20px;
        }
    </style>
</head>
<body>
<canvas id="timelineCanvas"></canvas>

<script>

function processData(data) {
    // Find minimum start time
    const minTime = Math.min(...data.map(block => block.start_time));
    const mintimespan = Math.min(...data.map(block => block.timespan));
    //
    const maxChunkId = Math.max(...data.map(block => block.chunk_id));

    // Adjust times and convert to milliseconds
    data.forEach(block => {
        block.start_time = (block.start_time - minTime) / mintimespan/100;
        block.timespan = block.timespan / mintimespan/100;
    });

    // Group by local_rank and operation type
    const groupedData = {};
    data.forEach(block => {
        if (!groupedData[block.local_rank]) {
            groupedData[block.local_rank] = {
                compute: [],
                communicate: []
            };
        }
        if (block.operation.startsWith('compute')) {
            groupedData[block.local_rank].compute.push(block);
        } else if (block.operation.startsWith('communicate')) {
            groupedData[block.local_rank].communicate.push(block);
        }
    });

    // Sort blocks within each group
    Object.values(groupedData).forEach(stage => {
        stage.compute.sort((a, b) => a.start_time - b.start_time);
        stage.communicate.sort((a, b) => a.start_time - b.start_time);
    });

    return groupedData;
}

function drawTimeline(data) {
    const canvas = document.getElementById('timelineCanvas');
    const ctx = canvas.getContext('2d');
    const blockHeightY = 16;
    const blockHeight = 30;         // 每个block的高度
    const rowSpacing = 20;          // 行间距
    const rowHeight = blockHeight * 2 + rowSpacing; // 每行的总高度
    const xOffset = 100;            // 左边距
    const yOffset = 30;             // 上边距

    // Calculate canvas dimensions
    const stages = Object.keys(data).sort((a, b) => Number(a) - Number(b));

    // 计算最大时间，来确定画布的宽度
    const maxTime = Math.max(...Object.values(data).flatMap(stage => 
        [...stage.compute, ...stage.communicate].map(block => 
            block.start_time + block.timespan
        )
    ));

    // 根据最大时间设置画布宽度，宽度为时间的10倍，确保足够显示
    canvas.width = 50000//maxTime+ xOffset; 
    canvas.height = stages.length * rowHeight + yOffset * 2;

    // 清除画布
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw timeline for each stage
    stages.forEach((localRank, index) => {
        const y = index * rowHeight + yOffset;

        // 绘制stage标签
        ctx.fillStyle = 'black';
        ctx.font = '10px Arial';
        ctx.fillText(`rank ${localRank}`, 5, y + blockHeight);

        // 绘制compute类型的block
        data[localRank].compute.forEach(block => {
            const x = block.start_time+ xOffset;
            const width = block.timespan;// 增加宽度最小值，避免block太小
            //const alpha = 1-block.chunk_id/maxChunkId;
            // 根据step_type设置颜色
            switch (block.step_type) {
                case 'f':
                    color = 'rgba(0, 0, 255, 1)';
                    break;
                case 'b':
                    color = 'rgba(255, 255, 0, 1)';
                    break;
                case 'w':
                    color = 'rgba(0, 255, 0, 1)';
                    break;
                default:
                    // 可以添加默认的颜色和位置设置
                    color = 'gray';

            }
            ctx.fillStyle = color;

            ctx.fillRect(x, y, width, blockHeight);
            ctx.strokeRect(x, y, width, blockHeight);

            // 添加文本
            ctx.fillStyle = block.step_type === 'b' ? 'black' : 'white';
            ctx.font = '10px Arial';
            ctx.fillText(block.microbatch_id, x+(width/2), y + blockHeight - 10);
        });

//绘制communicate类型的block
// 假设 data、localRank、ctx 已经正确定义
// 假设 y 和 xOffset 已经正确定义
        // data[localRank].communicate.forEach(block => {
        //     const x = block.start_time + xOffset;
        //     const width = block.timespan; // 增加宽度最小值，避免 block 太小
        //     let y2;
        //     let color;
        //     //const alpha = 1- block.chunk_id/maxChunkId;
        //     const communicate_type = block.operation.split(':').at(-1).split(";")[0];
        //     switch (communicate_type) {
        //         case 'send_forward':
        //             color = 'rgba(0, 0, 255, 0.5)';
        //             y2 = y + blockHeight;
        //             break;
        //         case 'send_backward':
        //             color = 'rgba(255, 255, 0, 0.5)';
        //             y2 = y - blockHeightY ;
        //             break;
        //         case 'recv_forward':
        //             color = 'rgba(0, 0, 255, 0.5)';
        //             y2 = y - blockHeightY ;
        //             break;
        //         case 'recv_backward':
        //             color = 'rgba(255, 255, 0, 0.5)';
        //             y2 = y + blockHeight;
        //             break;
        //         default:
        //             // 可以添加默认的颜色和位置设置
        //             color = 'gray';
        //             y2 = 0;
        //     }

        //     ctx.fillStyle = color;
        //     ctx.fillRect(x, y2, width, blockHeightY);
        //     ctx.strokeRect(x, y2, width, blockHeightY);


        //     //添加文本
        //     ctx.fillStyle = 'black';
        //     ctx.font = '10px Arial';
        //     ctx.fillText(block.microbatch_id, x+(width/2), y2 + blockHeightY/2);
        // });
    });
}

// 处理数据并绘制图形
fetch('/jsonResult/iter_20_opeartion_list.json')
    .then(response => response.text())
    .then(text => {
        // 将文本按JSON对象分割并解析
        const regex = /{[^}]+}/g;
        const data = Array.from(text.matchAll(regex)).map(match => JSON.parse(match[0]));
        // 使用解析后的数据
        const processedData = processData(data);
        drawTimeline(processedData);
    })
    .catch(error => console.error('Error loading the file:', error));

</script>
</body>
</html>